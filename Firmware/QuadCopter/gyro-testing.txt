#ifndef GYRO_H
#define GYRO_H

#include "Arduino.h"
#include "adc.h"

#define FINDZERO 49

float gyroRate[3] = {0.0,0.0,0.0};
int   gyroZero[3] = {0,0,0};
long  gyroSample[3] = {0,0,0};
float gyroSmoothFactor = 1.0;

float gyroHeading = 0.0;
unsigned long gyroLastMesuredTime = 0;

void measureGyroSum();
void evaluateGyroRate();

byte gyroSampleCount = 0;

float filterSmooth(float currentData, float previousData, float smoothFactor) 
{
  if (smoothFactor != 1.0) //only apply time compensated filter if smoothFactor is applied
  {
    return (previousData * (1.0 - smoothFactor) + (currentData * smoothFactor)); 
  }
  return currentData; //if smoothFactor == 1.0, do not calculate, just bypass!
}

int findMedianInt(int *data, int arraySize) 
{
  int temp;
  boolean done = 0;
  byte i;
  
   // Sorts numbers from lowest to highest
  while (done != 1) 
  {        
    done = 1;
    for (i=0; i<(arraySize-1); i++) 
	{
      if (data[i] > data[i+1]) 
	  {     // numbers are out of order - swap
        temp = data[i+1];
        data[i+1] = data[i];
        data[i] = temp;
        done = 0;
      }
    }
  }
  
  return data[arraySize/2]; // return the median value
}
  
void initializeGyro();
void measureGyro();
void calibrateGyro();

int gyroChannel[3] = {0.0,0.0,0.0};
float gyroAref = 3.3;
float gyroScaleFactor = radians((gyroAref/4095.0) / 0.002);



void measureGyro() {
  int gyroADC;
  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
    if (axis == XAXIS)
      gyroADC = gyroZero[axis] - getRawADC(axis+3);
    else
      gyroADC = getRawADC(axis+3) - gyroZero[axis];
    gyroRate[axis] = filterSmooth(gyroADC * gyroScaleFactor, gyroRate[axis], gyroSmoothFactor);
  }
 
  // Measure gyro heading
  long int currentTime = micros();
  if (gyroRate[ZAXIS] > radians(1.0) || gyroRate[ZAXIS] < radians(-1.0)) {
    gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
  }
  gyroLastMesuredTime = currentTime;
}

void measureGyroSum() {
  
  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
    gyroSample[axis] += getRawADC(axis + 3);
  }
  gyroSampleCount++;
}

void evaluateGyroRate() {
  int gyroADC;
  for (byte axis = XAXIS; axis <= ZAXIS; axis++) {
    if (axis == XAXIS)
      gyroADC = (gyroSample[axis] / gyroSampleCount) - gyroZero[axis];
    else
      gyroADC = gyroZero[axis] - (gyroSample[axis] / gyroSampleCount);
    gyroRate[axis] = filterSmooth(gyroADC * gyroScaleFactor, gyroRate[axis], gyroSmoothFactor);
  }
  gyroSample[0] = 0;
  gyroSample[1] = 0;
  gyroSample[2] = 0;
  gyroSampleCount = 0;
  
  // Measure gyro heading
  long int currentTime = micros();
  if (gyroRate[ZAXIS] > radians(1.0) || gyroRate[ZAXIS] < radians(-1.0)) {
    gyroHeading += gyroRate[ZAXIS] * ((currentTime - gyroLastMesuredTime) / 1000000.0);
  }
  gyroLastMesuredTime = currentTime;
}

void calibrateGyro() {
  int findZero[FINDZERO];
   gyroChannel[0] = 3;
gyroChannel[1] = 4;
gyroChannel[2] = 5;
  for (byte axis = 0; axis < 3; axis++) {
    for (int i=0; i<FINDZERO; i++) {
      findZero[i] = getRawADC(axis+3);
      delay(10);
    }
    gyroZero[axis] = findMedianInt(findZero, FINDZERO);
  }
}


#endif
